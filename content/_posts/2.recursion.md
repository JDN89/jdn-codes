## Slow recursion - dynamic programming to the rescue

https://excalidraw.com/ to draw stuff

#### The LeetCode problem - Climbing stairs

You are climbing a staircase. It takes n steps to reach the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

#### Example
```
Input: n = 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
```

#### Recursion explained

notes recursion
- base case
- recursive case
- Stack
    - LIFO 
#### First attempt - recursion

```ts
public class Solution {
    public int NumWays(int n) {
        //base case;
        if (n ==1 || n== 0 ) {
            return 1;
        } else {
            
        return NumWays(n-1) + NumWays(n-2);
        }
        
    }
}
```

#### The Issue

![Recursion Image](/Recursion-problem.svg){.dark:invert .mx-auto}
As you can tell by the my drawing, this recursive function has overlapping subproblems and calls itself more then once.
Reducing the efficiency of my recursvie function ot O(2^n), causing the LeetCode error : Time Limit Exceeded

#### Failure

I thought to solve this issue with recursion and I was passing the tests until n = 34.
For bigger values I received the error : Time Limit Exceeded. This 


#### Dynamic programming through Memoization

Dynamic programming : Optimizing recursive problems that have overlapping supbroblems.
The concept of memoization is quiet simple, instead of making unecesarry recursive calls and recalcalculating the same values more then once, we store the previously computed values somehow.


![Recursion solution](/Recursion-dynamic-solution.svg){.dark:invert .mx-auto}

```ts

public class Solution {
    
    Dictionary<int,int> memo = new Dictionary<int,int>();
    public int ClimbStairs(int n) {
        if (n == 0 || n ==1) {
            return memo[n] = 1;
        }
        if (memo.ContainsKey(n)) {
            return memo[n];
        }
       else {
           return memo[n] = ClimbStairs(n-1) + ClimbStairs(n-2);
       } 
    }
}

```

Notes dynamic programming

#### Solution